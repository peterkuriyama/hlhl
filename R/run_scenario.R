#' Run Scenarios

#' Function to run scenarios in parallel. Returns three things, a list of all the output from
#' conduct_survey, cpue summarized by each value in loop_over, and summarized data for each year. 

#' @param ctl Output from make_ctl function
#' @param loop_over Vector of values to loop over
#' @param ncores  Number of cores to run in parallel, default is 1
#' @param to_change Specify which value to modify in lapply statement. Should be the values in
#' loop_over and be a character string 

#' @examples
#' ctl1 <- make_ctl(distribute = 'patchy', mortality = 0, move_out_prob = .5,
#'       nfish1 = 0, nfish2 = 0, prob1 = .01, prob2 = 0, nyear = 15, scope = 1, seed = 4,
#'       location = one_loc, numrow = 1, numcol = 1)  
#' ttest <- run_scenario(ctl = ctl, loop_over = seq(100, 1500, by = 100), to_change = 'nfish1', 
#'   ncores = 6)
#' @export

run_scenario <- function(ctl_in, loop_over, ncores = 1, to_change, add_index = FALSE){
  
  #Set up number of cores, default is 1
  # cl <- makeCluster(ncores)
  # registerDoParallel(cl)
  # cat(getDoParWorkers(), "cores registered", '\n')

  #--------------------------------------------------------------------------------
  #Create list of ctls that based on inputs
  #If loop over is a vector or a list, replace to_change in ctl_temp with different
  #notation
  if(class(loop_over) != 'list'){
    ctl_list <- lapply(loop_over, function(xx){
      ctl_temp <- ctl_in
      ctl_temp[to_change] <- xx
      return(ctl_temp)
    })
  }

  if(class(loop_over) == 'list'){
    ctl_list <- lapply(loop_over, function(xx){
      ctl_temp <- ctl_in
      ctl_temp[[to_change]] <- xx
      return(ctl_temp)
    })
  }

  #Add index to ctl_list
  for(nn in 1:length(ctl_list)){
    ctl_list[[nn]]$nname <- nn
  }

  #Run the mclapply call
  out_list <- mclapply(ctl_list, mc.cores = ncores, FUN = function(xx){
    print(xx$nname)
    ctl <- xx
    out <- conduct_survey(ctl = ctl)
    return(out)    
  })


  #--------------------------------------------------------------------------------
  #Number of fish after each sampling
  nfish <-  lapply(out_list, FUN = function(x){
    temp <- "["(x$fished_areas)
    out <- melt(temp) %>% group_by(L1, L2) %>% summarize(nfish = sum(value)) %>% as.data.frame %>%
      dcast(L1 ~ L2, value.var = 'nfish')
  
  })
  names(nfish) <- as.character(1:length(nfish))
  nfish <- ldply(nfish)
  names(nfish) <- c('index', 'year', 'nfish1', 'nfish2')
  #remove "year" from year values
  nfish$year <- as.numeric(gsub("year", "", nfish$year))

  #Record number of fish caught each year
  nsamps <- lapply(out_list, FUN = function(x){
    x$samples %>% group_by(year) %>% summarize(fish1samp = sum(fish1samp), fish2samp = sum(fish2samp)) %>%
      arrange(desc(year)) %>% as.data.frame
  })
  names(nsamps) <- as.character(1:length(nsamps))
  nsamps <- ldply(nsamps)
  names(nsamps)[1] <- 'index'
  nsamps$year <- as.numeric(nsamps$year)
  
  nall <- left_join(nfish, nsamps, by = c('index', 'year'))
  
  #arrange nall by index then year
  nall <- nall %>% arrange(index, year)
  #--------------------------------------------------------------------------------
  #Format input plots
  #Format inputs for plots
  inp_list <- lapply(out_list, function(xx){
    format_plot_input(out = xx)
  })
  
  #Format inp_list
  names(inp_list) <- as.character(loop_over)
  inp_df <- ldply(inp_list)
  names(inp_df)[1] <- to_change

  #--------------------------------------------------------------------------------
  #Format for_plot output
  #Use substitute to group_by the character column name in to_change
  call <- substitute(inp_df %>% group_by(to_change, year, variable) %>% 
      summarize(cpue = mean(value), nfish = unique(nfish)) %>% as.data.frame, 
      list(to_change = as.name(to_change)))
  for_plot <- eval(call)

  #add total number of fish in
  call <- substitute(for_plot %>% group_by(to_change, year) %>% 
      mutate(nfish_tot = sum(nfish)) %>% as.data.frame, 
      list(to_change = as.name(to_change)))
  for_plot <- eval(call)

  #order for_plot stuff
  if(class(loop_over) != 'list'){
    for_plot[, to_change] <- as.numeric(for_plot[, to_change])
    for_plot <- for_plot[order(for_plot[, to_change]), ]
  }

  #Add unique index if looping over a list of locations for example
  if(add_index == TRUE){
    col_1 <- unique(for_plot[1])
    col_1 <- col_1[order(sapply(col_1, FUN = nchar)), ]

    inds <- sapply(ctl_list, FUN = function(xx) xx$nn)
    ind_df <- data.frame(col_1, inds = inds )
    names(ind_df)[1] <- as.character(to_change)
    ind_df[, to_change] <- as.character(ind_df[, to_change])

    dd <- left_join(for_plot, ind_df, by = as.character(to_change))
    dd[, to_change] <- dd$inds
    dd$inds <- NULL
    for_plot <- dd
  }

  #Add in values from the ctl file
  add_these <- c('nfish1', 'nfish2', 'prob1', 'prob2')
  already_in <- names(for_plot)[names(for_plot) %in% names(ctl)]

  still_add <- add_these[add_these %in% already_in == FALSE]

  #loop over still_add
  for(ll in 1:length(still_add)){
    run_this <- paste0("for_plot$", still_add[ll], " <- ", ctl[still_add][ll])
    eval(parse(text = run_this))    
  }

  #--------------------------------------------------------------------------------
  #Now return everything
  return(list(outs = out_list, summ_out = inp_df, for_plot = for_plot, fish_count = nall))

}


